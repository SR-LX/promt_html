Help on package mcp:

NAME
    mcp

PACKAGE CONTENTS
    cli (package)
    client (package)
    server (package)
    shared (package)
    types

CLASSES
    builtins.Exception(builtins.BaseException)
        mcp.shared.exceptions.McpError
    mcp.shared.session.BaseSession(typing.Generic)
        mcp.client.session.ClientSession
        mcp.server.session.ServerSession
    mcp.types.Notification[LoggingMessageNotificationParams, Literal['notifications/message']](mcp.types.Notification)
        mcp.types.LoggingMessageNotification
    mcp.types.Notification[ProgressNotificationParams, Literal['notifications/progress']](mcp.types.Notification)
        mcp.types.ProgressNotification
    mcp.types.Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']](mcp.types.Notification)
        mcp.types.ResourceUpdatedNotification
    mcp.types.Notification[Union[NotificationParams, NoneType], Literal['notifications/initialized']](mcp.types.Notification)
        mcp.types.InitializedNotification
    mcp.types.PaginatedRequest[Union[RequestParams, NoneType], Literal['prompts/list']](mcp.types.PaginatedRequest)
        mcp.types.ListPromptsRequest
    mcp.types.PaginatedRequest[Union[RequestParams, NoneType], Literal['resources/list']](mcp.types.PaginatedRequest)
        mcp.types.ListResourcesRequest
    mcp.types.PaginatedResult(mcp.types.Result)
        mcp.types.ListPromptsResult
        mcp.types.ListResourcesResult
        mcp.types.ListToolsResult
    mcp.types.Request[CallToolRequestParams, Literal['tools/call']](mcp.types.Request)
        mcp.types.CallToolRequest
    mcp.types.Request[CompleteRequestParams, Literal['completion/complete']](mcp.types.Request)
        mcp.types.CompleteRequest
    mcp.types.Request[CreateMessageRequestParams, Literal['sampling/createMessage']](mcp.types.Request)
        mcp.types.CreateMessageRequest
    mcp.types.Request[GetPromptRequestParams, Literal['prompts/get']](mcp.types.Request)
        mcp.types.GetPromptRequest
    mcp.types.Request[InitializeRequestParams, Literal['initialize']](mcp.types.Request)
        mcp.types.InitializeRequest
    mcp.types.Request[ReadResourceRequestParams, Literal['resources/read']](mcp.types.Request)
        mcp.types.ReadResourceRequest
    mcp.types.Request[SetLevelRequestParams, Literal['logging/setLevel']](mcp.types.Request)
        mcp.types.SetLevelRequest
    mcp.types.Request[SubscribeRequestParams, Literal['resources/subscribe']](mcp.types.Request)
        mcp.types.SubscribeRequest
    mcp.types.Request[Union[RequestParams, NoneType], Literal['ping']](mcp.types.Request)
        mcp.types.PingRequest
    mcp.types.Request[Union[dict[str, Any], NoneType], str](mcp.types.Request)
        mcp.types.JSONRPCRequest
    mcp.types.Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']](mcp.types.Request)
        mcp.types.UnsubscribeRequest
    mcp.types.Result(pydantic.main.BaseModel)
        mcp.types.CreateMessageResult
        mcp.types.GetPromptResult
        mcp.types.InitializeResult
        mcp.types.ReadResourceResult
    pydantic.main.BaseModel(builtins.object)
        mcp.client.stdio.StdioServerParameters
        mcp.types.ClientCapabilities
        mcp.types.ErrorData
        mcp.types.Implementation
        mcp.types.JSONRPCError
        mcp.types.JSONRPCResponse
        mcp.types.Notification(pydantic.main.BaseModel, typing.Generic)
        mcp.types.PromptsCapability
        mcp.types.Resource
        mcp.types.ResourcesCapability
        mcp.types.RootsCapability
        mcp.types.SamplingMessage
        mcp.types.ServerCapabilities
        mcp.types.Tool
        mcp.types.ToolsCapability
    pydantic.root_model.RootModel[Union[CancelledNotification, ProgressNotification, InitializedNotification, RootsListChangedNotification]](pydantic.root_model.RootModel)
        mcp.types.ClientNotification
    pydantic.root_model.RootModel[Union[CancelledNotification, ProgressNotification, LoggingMessageNotification, ResourceUpdatedNotification, ResourceListChangedNotification, ToolListChangedNotification, PromptListChangedNotification]](pydantic.root_model.RootModel)
        mcp.types.ServerNotification
    pydantic.root_model.RootModel[Union[EmptyResult, CreateMessageResult, ListRootsResult]](pydantic.root_model.RootModel)
        mcp.types.ClientResult
    pydantic.root_model.RootModel[Union[EmptyResult, InitializeResult, CompleteResult, GetPromptResult, ListPromptsResult, ListResourcesResult, ListResourceTemplatesResult, ReadResourceResult, CallToolResult, ListToolsResult]](pydantic.root_model.RootModel)
        mcp.types.ServerResult
    pydantic.root_model.RootModel[Union[PingRequest, CreateMessageRequest, ListRootsRequest]](pydantic.root_model.RootModel)
        mcp.types.ServerRequest
    pydantic.root_model.RootModel[Union[PingRequest, InitializeRequest, CompleteRequest, SetLevelRequest, GetPromptRequest, ListPromptsRequest, ListResourcesRequest, ListResourceTemplatesRequest, ReadResourceRequest, SubscribeRequest, UnsubscribeRequest, CallToolRequest, ListToolsRequest]](pydantic.root_model.RootModel)
        mcp.types.ClientRequest
    typing.Generic(builtins.object)
        mcp.types.Notification(pydantic.main.BaseModel, typing.Generic)

    class CallToolRequest(Request[CallToolRequestParams, Literal['tools/call']])
     |  CallToolRequest(*, method: Literal['tools/call'], params: mcp.types.CallToolRequestParams, **extra_data: Any) -> None
     |
     |  Used by the client to invoke a tool provided by the server.
     |
     |  Method resolution order:
     |      CallToolRequest
     |      Request[CallToolRequestParams, Literal['tools/call']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['tools/call'], 'params': <...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.CallToolRequest'>...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=Literal['tools/c...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="CallToolRequest", vali...
     |
     |  __signature__ = <Signature (*, method: Literal['tools/call'], pa...all...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=Literal['tools/call'], ...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class ClientCapabilities(pydantic.main.BaseModel)
     |  ClientCapabilities(*, experimental: dict[str, dict[str, typing.Any]] | None = None, sampling: mcp.types.SamplingCapability | None = None, roots: mcp.types.RootsCapability | None = None, **extra_data: Any) -> None
     |
     |  Capabilities a client may support.
     |
     |  Method resolution order:
     |      ClientCapabilities
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'experimental': dict[str, dict[str, typing.Any]] | ...
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ClientCapabilitie...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'experimental': FieldInfo(annotation=Union[dict...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ClientCapabilities", v...
     |
     |  __signature__ = <Signature (*, experimental: dict[str, dict[str,...bil...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'experimental': FieldInfo(annotation=Union[dict[str, d...

    class ClientNotification(pydantic.root_model.RootModel[Union[CancelledNotification, ProgressNotification, InitializedNotification, RootsListChangedNotification]])
     |  ClientNotification(root: 'RootModelRootType' = PydanticUndefined) -> None
     |
     |  Method resolution order:
     |      ClientNotification
     |      pydantic.root_model.RootModel[Union[CancelledNotification, ProgressNotification, InitializedNotification, RootsListChangedNotification]]
     |      pydantic.root_model.RootModel
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {}
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ClientNotificatio...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'root': FieldInfo(annotation=Union[CancelledNot...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ClientNotification", v...
     |
     |  __signature__ = <Signature (root: 'RootModelRootType' = PydanticUndefi...
     |
     |  model_config = {}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.root_model.RootModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.root_model.RootModel:
     |
     |  __init_subclass__(**kwargs)
     |      This method is called when a class is subclassed.
     |
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |
     |  model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
     |      Create a new model using the provided root object and update fields set.
     |
     |      Args:
     |          root: The root object of the model.
     |          _fields_set: The set of fields to be updated.
     |
     |      Returns:
     |          The new model.
     |
     |      Raises:
     |          NotImplemented: If the model is not a subclass of `RootModel`.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.root_model.RootModel:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.root_model.RootModel:
     |
     |  __hash__ = None
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  __pydantic_extra__ = None
     |
     |  __pydantic_private__ = None
     |
     |  __pydantic_root_model__ = True
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_fields_set__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'root': FieldInfo(annotation=Union[CancelledNotificati...

    class ClientRequest(pydantic.root_model.RootModel[Union[PingRequest, InitializeRequest, CompleteRequest, SetLevelRequest, GetPromptRequest, ListPromptsRequest, ListResourcesRequest, ListResourceTemplatesRequest, ReadResourceRequest, SubscribeRequest, UnsubscribeRequest, CallToolRequest, ListToolsRequest]])
     |  ClientRequest(root: 'RootModelRootType' = PydanticUndefined) -> None
     |
     |  Method resolution order:
     |      ClientRequest
     |      pydantic.root_model.RootModel[Union[PingRequest, InitializeRequest, CompleteRequest, SetLevelRequest, GetPromptRequest, ListPromptsRequest, ListResourcesRequest, ListResourceTemplatesRequest, ReadResourceRequest, SubscribeRequest, UnsubscribeRequest, CallToolRequest, ListToolsRequest]]
     |      pydantic.root_model.RootModel
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {}
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ClientRequest'>, ...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'root': FieldInfo(annotation=Union[PingRequest,...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ClientRequest", valida...
     |
     |  __signature__ = <Signature (root: 'RootModelRootType' = PydanticUndefi...
     |
     |  model_config = {}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.root_model.RootModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.root_model.RootModel:
     |
     |  __init_subclass__(**kwargs)
     |      This method is called when a class is subclassed.
     |
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |
     |  model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
     |      Create a new model using the provided root object and update fields set.
     |
     |      Args:
     |          root: The root object of the model.
     |          _fields_set: The set of fields to be updated.
     |
     |      Returns:
     |          The new model.
     |
     |      Raises:
     |          NotImplemented: If the model is not a subclass of `RootModel`.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.root_model.RootModel:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.root_model.RootModel:
     |
     |  __hash__ = None
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  __pydantic_extra__ = None
     |
     |  __pydantic_private__ = None
     |
     |  __pydantic_root_model__ = True
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_fields_set__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'root': FieldInfo(annotation=Union[PingRequest, Initia...

    class ClientResult(pydantic.root_model.RootModel[Union[EmptyResult, CreateMessageResult, ListRootsResult]])
     |  ClientResult(root: 'RootModelRootType' = PydanticUndefined) -> None
     |
     |  Method resolution order:
     |      ClientResult
     |      pydantic.root_model.RootModel[Union[EmptyResult, CreateMessageResult, ListRootsResult]]
     |      pydantic.root_model.RootModel
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {}
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ClientResult'>, '...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'root': FieldInfo(annotation=Union[EmptyResult,...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ClientResult", validat...
     |
     |  __signature__ = <Signature (root: 'RootModelRootType' = PydanticUndefi...
     |
     |  model_config = {}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.root_model.RootModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.root_model.RootModel:
     |
     |  __init_subclass__(**kwargs)
     |      This method is called when a class is subclassed.
     |
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |
     |  model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
     |      Create a new model using the provided root object and update fields set.
     |
     |      Args:
     |          root: The root object of the model.
     |          _fields_set: The set of fields to be updated.
     |
     |      Returns:
     |          The new model.
     |
     |      Raises:
     |          NotImplemented: If the model is not a subclass of `RootModel`.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.root_model.RootModel:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.root_model.RootModel:
     |
     |  __hash__ = None
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  __pydantic_extra__ = None
     |
     |  __pydantic_private__ = None
     |
     |  __pydantic_root_model__ = True
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_fields_set__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'root': FieldInfo(annotation=Union[EmptyResult, Create...

    class ClientSession(mcp.shared.session.BaseSession)
     |  ClientSession(read_stream: anyio.streams.memory.MemoryObjectReceiveStream[mcp.types.JSONRPCMessage | Exception], write_stream: anyio.streams.memory.MemoryObjectSendStream[mcp.types.JSONRPCMessage], read_timeout_seconds: datetime.timedelta | None = None, sampling_callback: mcp.client.session.SamplingFnT | None = None, list_roots_callback: mcp.client.session.ListRootsFnT | None = None, logging_callback: mcp.client.session.LoggingFnT | None = None, message_handler: mcp.client.session.MessageHandlerFnT | None = None) -> None
     |
     |  Method resolution order:
     |      ClientSession
     |      mcp.shared.session.BaseSession
     |      typing.Generic
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self, read_stream: anyio.streams.memory.MemoryObjectReceiveStream[mcp.types.JSONRPCMessage | Exception], write_stream: anyio.streams.memory.MemoryObjectSendStream[mcp.types.JSONRPCMessage], read_timeout_seconds: datetime.timedelta | None = None, sampling_callback: mcp.client.session.SamplingFnT | None = None, list_roots_callback: mcp.client.session.ListRootsFnT | None = None, logging_callback: mcp.client.session.LoggingFnT | None = None, message_handler: mcp.client.session.MessageHandlerFnT | None = None) -> None
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  async call_tool(self, name: str, arguments: dict[str, typing.Any] | None = None) -> mcp.types.CallToolResult
     |      Send a tools/call request.
     |
     |  async complete(self, ref: mcp.types.ResourceReference | mcp.types.PromptReference, argument: dict[str, str]) -> mcp.types.CompleteResult
     |      Send a completion/complete request.
     |
     |  async get_prompt(self, name: str, arguments: dict[str, str] | None = None) -> mcp.types.GetPromptResult
     |      Send a prompts/get request.
     |
     |  async initialize(self) -> mcp.types.InitializeResult
     |
     |  async list_prompts(self) -> mcp.types.ListPromptsResult
     |      Send a prompts/list request.
     |
     |  async list_resource_templates(self) -> mcp.types.ListResourceTemplatesResult
     |      Send a resources/templates/list request.
     |
     |  async list_resources(self) -> mcp.types.ListResourcesResult
     |      Send a resources/list request.
     |
     |  async list_tools(self) -> mcp.types.ListToolsResult
     |      Send a tools/list request.
     |
     |  async read_resource(self, uri: pydantic.networks.AnyUrl) -> mcp.types.ReadResourceResult
     |      Send a resources/read request.
     |
     |  async send_ping(self) -> mcp.types.EmptyResult
     |      Send a ping request.
     |
     |  async send_progress_notification(self, progress_token: str | int, progress: float, total: float | None = None) -> None
     |      Send a progress notification.
     |
     |  async send_roots_list_changed(self) -> None
     |      Send a roots/list_changed notification.
     |
     |  async set_logging_level(self, level: Literal['debug', 'info', 'notice', 'warning', 'error', 'critical', 'alert', 'emergency']) -> mcp.types.EmptyResult
     |      Send a logging/setLevel request.
     |
     |  async subscribe_resource(self, uri: pydantic.networks.AnyUrl) -> mcp.types.EmptyResult
     |      Send a resources/subscribe request.
     |
     |  async unsubscribe_resource(self, uri: pydantic.networks.AnyUrl) -> mcp.types.EmptyResult
     |      Send a resources/unsubscribe request.
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {}
     |
     |  __orig_bases__ = (mcp.shared.session.BaseSession[mcp.types.ClientR...y...
     |
     |  __parameters__ = ()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from mcp.shared.session.BaseSession:
     |
     |  async __aenter__(self) -> Self
     |
     |  async __aexit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: traceback | None) -> bool | None
     |
     |  async send_notification(self, notification: ~SendNotificationT) -> None
     |      Emits a notification, which is a one-way message that does not expect
     |      a response.
     |
     |  async send_request(self, request: ~SendRequestT, result_type: type[~ReceiveResultT]) -> ~ReceiveResultT
     |      Sends a request and wait for a response. Raises an McpError if the
     |      response contains an error.
     |
     |      Do not use this method to emit notifications! Use send_notification()
     |      instead.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from mcp.shared.session.BaseSession:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __class_getitem__(...)
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class CompleteRequest(Request[CompleteRequestParams, Literal['completion/complete']])
     |  CompleteRequest(*, method: Literal['completion/complete'], params: mcp.types.CompleteRequestParams, **extra_data: Any) -> None
     |
     |  A request from the client to the server, to ask for completion options.
     |
     |  Method resolution order:
     |      CompleteRequest
     |      Request[CompleteRequestParams, Literal['completion/complete']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['completion/complete'], 'p...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.CompleteRequest'>...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=Literal['complet...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="CompleteRequest", vali...
     |
     |  __signature__ = <Signature (*, method: Literal['completion/compl...omp...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=Literal['completion/com...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class CreateMessageRequest(Request[CreateMessageRequestParams, Literal['sampling/createMessage']])
     |  CreateMessageRequest(*, method: Literal['sampling/createMessage'], params: mcp.types.CreateMessageRequestParams, **extra_data: Any) -> None
     |
     |  A request from the server to sample an LLM via the client.
     |
     |  Method resolution order:
     |      CreateMessageRequest
     |      Request[CreateMessageRequestParams, Literal['sampling/createMessage']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['sampling/createMessage'],...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.CreateMessageRequ...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=Literal['samplin...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="CreateMessageRequest",...
     |
     |  __signature__ = <Signature (*, method: Literal['sampling/createM...Mes...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=Literal['sampling/creat...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class CreateMessageResult(Result)
     |  CreateMessageResult(*, _meta: dict[str, typing.Any] | None = None, role: Literal['user', 'assistant'], content: mcp.types.TextContent | mcp.types.ImageContent, model: str, stopReason: Union[Literal['endTurn', 'stopSequence', 'maxTokens'], str, NoneType] = None, **extra_data: Any) -> None
     |
     |  The client's response to a sampling/create_message request from the server.
     |
     |  Method resolution order:
     |      CreateMessageResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'content': mcp.types.TextContent | mcp.types.ImageC...
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.CreateMessageResu...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'content': FieldInfo(annotation=Union[TextConte...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="CreateMessageResult", ...
     |
     |  __signature__ = <Signature (*, _meta: dict[str, typing.Any] | No...tr,...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'content': FieldInfo(annotation=Union[TextContent, Ima...

    class ErrorData(pydantic.main.BaseModel)
     |  ErrorData(*, code: int, message: str, data: typing.Any | None = None, **extra_data: Any) -> None
     |
     |  Error information for JSON-RPC error responses.
     |
     |  Method resolution order:
     |      ErrorData
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'code': <class 'int'>, 'data': typing.Any | None, '...
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ErrorData'>, 'con...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'code': FieldInfo(annotation=int, required=True...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ErrorData", validator=...
     |
     |  __signature__ = <Signature (*, code: int, message: str, data: typing.A...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'code': FieldInfo(annotation=int, required=True), 'dat...

    class GetPromptRequest(Request[GetPromptRequestParams, Literal['prompts/get']])
     |  GetPromptRequest(*, method: Literal['prompts/get'], params: mcp.types.GetPromptRequestParams, **extra_data: Any) -> None
     |
     |  Used by the client to get a prompt provided by the server.
     |
     |  Method resolution order:
     |      GetPromptRequest
     |      Request[GetPromptRequestParams, Literal['prompts/get']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['prompts/get'], 'params': ...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.GetPromptRequest'...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=Literal['prompts...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="GetPromptRequest", val...
     |
     |  __signature__ = <Signature (*, method: Literal['prompts/get'], p...tPr...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=Literal['prompts/get'],...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class GetPromptResult(Result)
     |  GetPromptResult(*, _meta: dict[str, typing.Any] | None = None, description: str | None = None, messages: list[mcp.types.PromptMessage], **extra_data: Any) -> None
     |
     |  The server's response to a prompts/get request from the client.
     |
     |  Method resolution order:
     |      GetPromptResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'description': str | None, 'messages': list[mcp.typ...
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.GetPromptResult'>...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'description': FieldInfo(annotation=Union[str, ...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="GetPromptResult", vali...
     |
     |  __signature__ = <Signature (*, _meta: dict[str, typing.Any] | No...typ...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'description': FieldInfo(annotation=Union[str, NoneTyp...

    class Implementation(pydantic.main.BaseModel)
     |  Implementation(*, name: str, version: str, **extra_data: Any) -> None
     |
     |  Describes the name and version of an MCP implementation.
     |
     |  Method resolution order:
     |      Implementation
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'name': <class 'str'>, 'version': <class 'str'>}
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.Implementation'>,...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'name': FieldInfo(annotation=str, required=True...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="Implementation", valid...
     |
     |  __signature__ = <Signature (*, name: str, version: str, **extra_data: ...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'name': FieldInfo(annotation=str, required=True), 'ver...

    class InitializeRequest(Request[InitializeRequestParams, Literal['initialize']])
     |  InitializeRequest(*, method: Literal['initialize'], params: mcp.types.InitializeRequestParams, **extra_data: Any) -> None
     |
     |  This request is sent from the client to the server when it first connects, asking it
     |  to begin initialization.
     |
     |  Method resolution order:
     |      InitializeRequest
     |      Request[InitializeRequestParams, Literal['initialize']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['initialize'], 'params': <...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.InitializeRequest...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=Literal['initial...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="InitializeRequest", va...
     |
     |  __signature__ = <Signature (*, method: Literal['initialize'], pa...tia...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=Literal['initialize'], ...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class InitializeResult(Result)
     |  InitializeResult(*, _meta: dict[str, typing.Any] | None = None, protocolVersion: str | int, capabilities: mcp.types.ServerCapabilities, serverInfo: mcp.types.Implementation, instructions: str | None = None, **extra_data: Any) -> None
     |
     |  After receiving an initialize request from the client, the server sends this.
     |
     |  Method resolution order:
     |      InitializeResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'capabilities': <class 'mcp.types.ServerCapabilitie...
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.InitializeResult'...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'capabilities': FieldInfo(annotation=ServerCapa...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="InitializeResult", val...
     |
     |  __signature__ = <Signature (*, _meta: dict[str, typing.Any] | No...s: ...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'capabilities': FieldInfo(annotation=ServerCapabilitie...

    class InitializedNotification(Notification[Union[NotificationParams, NoneType], Literal['notifications/initialized']])
     |  InitializedNotification(*, method: Literal['notifications/initialized'], params: mcp.types.NotificationParams | None = None, **extra_data: Any) -> None
     |
     |  This notification is sent from the client to the server after initialization has
     |  finished.
     |
     |  Method resolution order:
     |      InitializedNotification
     |      Notification[Union[NotificationParams, NoneType], Literal['notifications/initialized']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['notifications/initialized...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.InitializedNotifi...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=Literal['notific...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="InitializedNotificatio...
     |
     |  __signature__ = <Signature (*, method: Literal['notifications/in...Par...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=Literal['notifications/...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class JSONRPCError(pydantic.main.BaseModel)
     |  JSONRPCError(*, jsonrpc: Literal['2.0'], id: str | int, error: mcp.types.ErrorData, **extra_data: Any) -> None
     |
     |  A response to a request that indicates an error occurred.
     |
     |  Method resolution order:
     |      JSONRPCError
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'error': <class 'mcp.types.ErrorData'>, 'id': str |...
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.JSONRPCError'>, '...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'error': FieldInfo(annotation=ErrorData, requir...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="JSONRPCError", validat...
     |
     |  __signature__ = <Signature (*, jsonrpc: Literal['2.0'], id: str ... mc...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'error': FieldInfo(annotation=ErrorData, required=True...

    class JSONRPCRequest(Request[Union[dict[str, Any], NoneType], str])
     |  JSONRPCRequest(*, method: str, params: dict[str, typing.Any] | None = None, jsonrpc: Literal['2.0'], id: str | int, **extra_data: Any) -> None
     |
     |  A request that expects a response.
     |
     |  Method resolution order:
     |      JSONRPCRequest
     |      Request[Union[dict[str, Any], NoneType], str]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'id': str | int, 'jsonrpc': typing.Literal['2.0'], ...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.JSONRPCRequest'>,...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'id': FieldInfo(annotation=Union[str, int], req...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="JSONRPCRequest", valid...
     |
     |  __signature__ = <Signature (*, method: str, params: dict[str, ty...2.0...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'id': FieldInfo(annotation=Union[str, int], required=T...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class JSONRPCResponse(pydantic.main.BaseModel)
     |  JSONRPCResponse(*, jsonrpc: Literal['2.0'], id: str | int, result: dict[str, typing.Any], **extra_data: Any) -> None
     |
     |  A successful (non-error) response to a request.
     |
     |  Method resolution order:
     |      JSONRPCResponse
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'id': str | int, 'jsonrpc': typing.Literal['2.0'], ...
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.JSONRPCResponse'>...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'id': FieldInfo(annotation=Union[str, int], req...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="JSONRPCResponse", vali...
     |
     |  __signature__ = <Signature (*, jsonrpc: Literal['2.0'], id: str ...ict...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'id': FieldInfo(annotation=Union[str, int], required=T...

    class ListPromptsRequest(PaginatedRequest[Union[RequestParams, NoneType], Literal['prompts/list']])
     |  ListPromptsRequest(*, method: Literal['prompts/list'], params: mcp.types.RequestParams | None = None, cursor: str | None = None, **extra_data: Any) -> None
     |
     |  Sent from the client to request a list of prompts and prompt templates.
     |
     |  Method resolution order:
     |      ListPromptsRequest
     |      PaginatedRequest[Union[RequestParams, NoneType], Literal['prompts/list']]
     |      PaginatedRequest
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['prompts/list'], 'params':...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ListPromptsReques...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'cursor': FieldInfo(annotation=Union[str, NoneT...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ListPromptsRequest", v...
     |
     |  __signature__ = <Signature (*, method: Literal['prompts/list'], ...r: ...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'cursor': FieldInfo(annotation=Union[str, NoneType], r...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class ListPromptsResult(PaginatedResult)
     |  ListPromptsResult(*, _meta: dict[str, typing.Any] | None = None, nextCursor: str | None = None, prompts: list[mcp.types.Prompt], **extra_data: Any) -> None
     |
     |  The server's response to a prompts/list request from the client.
     |
     |  Method resolution order:
     |      ListPromptsResult
     |      PaginatedResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'prompts': list[mcp.types.Prompt]}
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ListPromptsResult...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'meta': FieldInfo(annotation=Union[dict[str, An...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ListPromptsResult", va...
     |
     |  __signature__ = <Signature (*, _meta: dict[str, typing.Any] | No...st[...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'meta': FieldInfo(annotation=Union[dict[str, Any], Non...

    class ListResourcesRequest(PaginatedRequest[Union[RequestParams, NoneType], Literal['resources/list']])
     |  ListResourcesRequest(*, method: Literal['resources/list'], params: mcp.types.RequestParams | None = None, cursor: str | None = None, **extra_data: Any) -> None
     |
     |  Sent from the client to request a list of resources the server has.
     |
     |  Method resolution order:
     |      ListResourcesRequest
     |      PaginatedRequest[Union[RequestParams, NoneType], Literal['resources/list']]
     |      PaginatedRequest
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['resources/list'], 'params...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ListResourcesRequ...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'cursor': FieldInfo(annotation=Union[str, NoneT...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ListResourcesRequest",...
     |
     |  __signature__ = <Signature (*, method: Literal['resources/list']...r: ...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'cursor': FieldInfo(annotation=Union[str, NoneType], r...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class ListResourcesResult(PaginatedResult)
     |  ListResourcesResult(*, _meta: dict[str, typing.Any] | None = None, nextCursor: str | None = None, resources: list[mcp.types.Resource], **extra_data: Any) -> None
     |
     |  The server's response to a resources/list request from the client.
     |
     |  Method resolution order:
     |      ListResourcesResult
     |      PaginatedResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'resources': list[mcp.types.Resource]}
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ListResourcesResu...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'meta': FieldInfo(annotation=Union[dict[str, An...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ListResourcesResult", ...
     |
     |  __signature__ = <Signature (*, _meta: dict[str, typing.Any] | No...[mc...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'meta': FieldInfo(annotation=Union[dict[str, Any], Non...

    class ListToolsResult(PaginatedResult)
     |  ListToolsResult(*, _meta: dict[str, typing.Any] | None = None, nextCursor: str | None = None, tools: list[mcp.types.Tool], **extra_data: Any) -> None
     |
     |  The server's response to a tools/list request from the client.
     |
     |  Method resolution order:
     |      ListToolsResult
     |      PaginatedResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'tools': list[mcp.types.Tool]}
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ListToolsResult'>...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'meta': FieldInfo(annotation=Union[dict[str, An...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ListToolsResult", vali...
     |
     |  __signature__ = <Signature (*, _meta: dict[str, typing.Any] | No...lis...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'meta': FieldInfo(annotation=Union[dict[str, Any], Non...

    class LoggingMessageNotification(Notification[LoggingMessageNotificationParams, Literal['notifications/message']])
     |  LoggingMessageNotification(*, method: Literal['notifications/message'], params: mcp.types.LoggingMessageNotificationParams, **extra_data: Any) -> None
     |
     |  Notification of a log message passed from server to client.
     |
     |  Method resolution order:
     |      LoggingMessageNotification
     |      Notification[LoggingMessageNotificationParams, Literal['notifications/message']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['notifications/message'], ...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.LoggingMessageNot...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=Literal['notific...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="LoggingMessageNotifica...
     |
     |  __signature__ = <Signature (*, method: Literal['notifications/me...geN...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=Literal['notifications/...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class McpError(builtins.Exception)
     |  McpError(error: mcp.types.ErrorData)
     |
     |  Exception type raised when an error arrives over an MCP connection.
     |
     |  Method resolution order:
     |      McpError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self, error: mcp.types.ErrorData)
     |      Initialize McpError.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {'error': <class 'mcp.types.ErrorData'>}
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |
     |  __new__(*args, **kwargs) class method of builtins.Exception
     |      Create and return a new object.  See help(type) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |
     |  __reduce__(...)
     |      Helper for pickle.
     |
     |  __repr__(self, /)
     |      Return repr(self).
     |
     |  __setstate__(...)
     |
     |  __str__(self, /)
     |      Return str(self).
     |
     |  add_note(...)
     |      Exception.add_note(note) --
     |      add a note to the exception
     |
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |
     |  __cause__
     |      exception cause
     |
     |  __context__
     |      exception context
     |
     |  __dict__
     |
     |  __suppress_context__
     |
     |  __traceback__
     |
     |  args

    class Notification(pydantic.main.BaseModel, typing.Generic)
     |  Notification(*, method: ~MethodT, params: ~NotificationParamsT, **extra_data: Any) -> None
     |
     |  Base class for JSON-RPC notifications.
     |
     |  Method resolution order:
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': ~MethodT, 'params': ~NotificationParamsT}
     |
     |  __class_vars__ = set()
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |
     |  __parameters__ = (~NotificationParamsT, ~MethodT)
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.Notification'>, '...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=TypeVar, require...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="Notification", validat...
     |
     |  __signature__ = <Signature (*, method: ~MethodT, params: ~Notification...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=TypeVar, required=True)...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class PingRequest(Request[Union[RequestParams, NoneType], Literal['ping']])
     |  PingRequest(*, method: Literal['ping'], params: mcp.types.RequestParams | None = None, **extra_data: Any) -> None
     |
     |  A ping, issued by either the server or the client, to check that the other party is
     |  still alive.
     |
     |  Method resolution order:
     |      PingRequest
     |      Request[Union[RequestParams, NoneType], Literal['ping']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['ping'], 'params': mcp.typ...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.PingRequest'>, 'c...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=Literal['ping'],...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="PingRequest", validato...
     |
     |  __signature__ = <Signature (*, method: Literal['ping'], params: ...Par...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=Literal['ping'], requir...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class ProgressNotification(Notification[ProgressNotificationParams, Literal['notifications/progress']])
     |  ProgressNotification(*, method: Literal['notifications/progress'], params: mcp.types.ProgressNotificationParams, **extra_data: Any) -> None
     |
     |  An out-of-band notification used to inform the receiver of a progress update for a
     |  long-running request.
     |
     |  Method resolution order:
     |      ProgressNotification
     |      Notification[ProgressNotificationParams, Literal['notifications/progress']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['notifications/progress'],...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ProgressNotificat...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=Literal['notific...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ProgressNotification",...
     |
     |  __signature__ = <Signature (*, method: Literal['notifications/pr...ssN...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=Literal['notifications/...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class PromptsCapability(pydantic.main.BaseModel)
     |  PromptsCapability(*, listChanged: bool | None = None, **extra_data: Any) -> None
     |
     |  Capability for prompts operations.
     |
     |  Method resolution order:
     |      PromptsCapability
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'listChanged': bool | None}
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.PromptsCapability...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'listChanged': FieldInfo(annotation=Union[bool,...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="PromptsCapability", va...
     |
     |  __signature__ = <Signature (*, listChanged: bool | None = None, **extr...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'listChanged': FieldInfo(annotation=Union[bool, NoneTy...

    class ReadResourceRequest(Request[ReadResourceRequestParams, Literal['resources/read']])
     |  ReadResourceRequest(*, method: Literal['resources/read'], params: mcp.types.ReadResourceRequestParams, **extra_data: Any) -> None
     |
     |  Sent from the client to the server, to read a specific resource URI.
     |
     |  Method resolution order:
     |      ReadResourceRequest
     |      Request[ReadResourceRequestParams, Literal['resources/read']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['resources/read'], 'params...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ReadResourceReque...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=Literal['resourc...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ReadResourceRequest", ...
     |
     |  __signature__ = <Signature (*, method: Literal['resources/read']...eso...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=Literal['resources/read...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class ReadResourceResult(Result)
     |  ReadResourceResult(*, _meta: dict[str, typing.Any] | None = None, contents: list[mcp.types.TextResourceContents | mcp.types.BlobResourceContents], **extra_data: Any) -> None
     |
     |  The server's response to a resources/read request from the client.
     |
     |  Method resolution order:
     |      ReadResourceResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'contents': list[mcp.types.TextResourceContents | m...
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ReadResourceResul...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'contents': FieldInfo(annotation=list[Union[Tex...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ReadResourceResult", v...
     |
     |  __signature__ = <Signature (*, _meta: dict[str, typing.Any] | No...lob...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'contents': FieldInfo(annotation=list[Union[TextResour...

    class Resource(pydantic.main.BaseModel)
     |  Resource(*, uri: Annotated[pydantic.networks.AnyUrl, UrlConstraints(max_length=None, allowed_schemes=None, host_required=False, default_host=None, default_port=None, default_path=None)], name: str, description: str | None = None, mimeType: str | None = None, size: int | None = None, annotations: mcp.types.Annotations | None = None, **extra_data: Any) -> None
     |
     |  A known resource that the server is capable of reading.
     |
     |  Method resolution order:
     |      Resource
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'annotations': mcp.types.Annotations | None, 'descr...
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.Resource'>, 'conf...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'annotations': FieldInfo(annotation=Union[Annot...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="Resource", validator=M...
     |
     |  __signature__ = <Signature (*, uri: Annotated[pydantic.networks....ati...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'annotations': FieldInfo(annotation=Union[Annotations,...

    class ResourceUpdatedNotification(Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']])
     |  ResourceUpdatedNotification(*, method: Literal['notifications/resources/updated'], params: mcp.types.ResourceUpdatedNotificationParams, **extra_data: Any) -> None
     |
     |  A notification from the server to the client, informing it that a resource has
     |  changed and may need to be read again.
     |
     |  Method resolution order:
     |      ResourceUpdatedNotification
     |      Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['notifications/resources/u...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ResourceUpdatedNo...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=Literal['notific...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ResourceUpdatedNotific...
     |
     |  __signature__ = <Signature (*, method: Literal['notifications/re...edN...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=Literal['notifications/...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class ResourcesCapability(pydantic.main.BaseModel)
     |  ResourcesCapability(*, subscribe: bool | None = None, listChanged: bool | None = None, **extra_data: Any) -> None
     |
     |  Capability for resources operations.
     |
     |  Method resolution order:
     |      ResourcesCapability
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'listChanged': bool | None, 'subscribe': bool | Non...
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ResourcesCapabili...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'listChanged': FieldInfo(annotation=Union[bool,...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ResourcesCapability", ...
     |
     |  __signature__ = <Signature (*, subscribe: bool | None = None, li...: b...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'listChanged': FieldInfo(annotation=Union[bool, NoneTy...

    class RootsCapability(pydantic.main.BaseModel)
     |  RootsCapability(*, listChanged: bool | None = None, **extra_data: Any) -> None
     |
     |  Capability for root operations.
     |
     |  Method resolution order:
     |      RootsCapability
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'listChanged': bool | None}
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.RootsCapability'>...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'listChanged': FieldInfo(annotation=Union[bool,...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="RootsCapability", vali...
     |
     |  __signature__ = <Signature (*, listChanged: bool | None = None, **extr...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'listChanged': FieldInfo(annotation=Union[bool, NoneTy...

    class SamplingMessage(pydantic.main.BaseModel)
     |  SamplingMessage(*, role: Literal['user', 'assistant'], content: mcp.types.TextContent | mcp.types.ImageContent, **extra_data: Any) -> None
     |
     |  Describes a message issued to or received from an LLM API.
     |
     |  Method resolution order:
     |      SamplingMessage
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'content': mcp.types.TextContent | mcp.types.ImageC...
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.SamplingMessage'>...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'content': FieldInfo(annotation=Union[TextConte...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="SamplingMessage", vali...
     |
     |  __signature__ = <Signature (*, role: Literal['user', 'assistant'...p.t...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'content': FieldInfo(annotation=Union[TextContent, Ima...

    class ServerCapabilities(pydantic.main.BaseModel)
     |  ServerCapabilities(*, experimental: dict[str, dict[str, typing.Any]] | None = None, logging: mcp.types.LoggingCapability | None = None, prompts: mcp.types.PromptsCapability | None = None, resources: mcp.types.ResourcesCapability | None = None, tools: mcp.types.ToolsCapability | None = None, **extra_data: Any) -> None
     |
     |  Capabilities that a server may support.
     |
     |  Method resolution order:
     |      ServerCapabilities
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'experimental': dict[str, dict[str, typing.Any]] | ...
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ServerCapabilitie...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'experimental': FieldInfo(annotation=Union[dict...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ServerCapabilities", v...
     |
     |  __signature__ = <Signature (*, experimental: dict[str, dict[str,...bil...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'experimental': FieldInfo(annotation=Union[dict[str, d...

    class ServerNotification(pydantic.root_model.RootModel[Union[CancelledNotification, ProgressNotification, LoggingMessageNotification, ResourceUpdatedNotification, ResourceListChangedNotification, ToolListChangedNotification, PromptListChangedNotification]])
     |  ServerNotification(root: 'RootModelRootType' = PydanticUndefined) -> None
     |
     |  Method resolution order:
     |      ServerNotification
     |      pydantic.root_model.RootModel[Union[CancelledNotification, ProgressNotification, LoggingMessageNotification, ResourceUpdatedNotification, ResourceListChangedNotification, ToolListChangedNotification, PromptListChangedNotification]]
     |      pydantic.root_model.RootModel
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {}
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ServerNotificatio...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'root': FieldInfo(annotation=Union[CancelledNot...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ServerNotification", v...
     |
     |  __signature__ = <Signature (root: 'RootModelRootType' = PydanticUndefi...
     |
     |  model_config = {}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.root_model.RootModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.root_model.RootModel:
     |
     |  __init_subclass__(**kwargs)
     |      This method is called when a class is subclassed.
     |
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |
     |  model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
     |      Create a new model using the provided root object and update fields set.
     |
     |      Args:
     |          root: The root object of the model.
     |          _fields_set: The set of fields to be updated.
     |
     |      Returns:
     |          The new model.
     |
     |      Raises:
     |          NotImplemented: If the model is not a subclass of `RootModel`.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.root_model.RootModel:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.root_model.RootModel:
     |
     |  __hash__ = None
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  __pydantic_extra__ = None
     |
     |  __pydantic_private__ = None
     |
     |  __pydantic_root_model__ = True
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_fields_set__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'root': FieldInfo(annotation=Union[CancelledNotificati...

    class ServerRequest(pydantic.root_model.RootModel[Union[PingRequest, CreateMessageRequest, ListRootsRequest]])
     |  ServerRequest(root: 'RootModelRootType' = PydanticUndefined) -> None
     |
     |  Method resolution order:
     |      ServerRequest
     |      pydantic.root_model.RootModel[Union[PingRequest, CreateMessageRequest, ListRootsRequest]]
     |      pydantic.root_model.RootModel
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {}
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ServerRequest'>, ...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'root': FieldInfo(annotation=Union[PingRequest,...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ServerRequest", valida...
     |
     |  __signature__ = <Signature (root: 'RootModelRootType' = PydanticUndefi...
     |
     |  model_config = {}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.root_model.RootModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.root_model.RootModel:
     |
     |  __init_subclass__(**kwargs)
     |      This method is called when a class is subclassed.
     |
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |
     |  model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
     |      Create a new model using the provided root object and update fields set.
     |
     |      Args:
     |          root: The root object of the model.
     |          _fields_set: The set of fields to be updated.
     |
     |      Returns:
     |          The new model.
     |
     |      Raises:
     |          NotImplemented: If the model is not a subclass of `RootModel`.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.root_model.RootModel:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.root_model.RootModel:
     |
     |  __hash__ = None
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  __pydantic_extra__ = None
     |
     |  __pydantic_private__ = None
     |
     |  __pydantic_root_model__ = True
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_fields_set__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'root': FieldInfo(annotation=Union[PingRequest, Create...

    class ServerResult(pydantic.root_model.RootModel[Union[EmptyResult, InitializeResult, CompleteResult, GetPromptResult, ListPromptsResult, ListResourcesResult, ListResourceTemplatesResult, ReadResourceResult, CallToolResult, ListToolsResult]])
     |  ServerResult(root: 'RootModelRootType' = PydanticUndefined) -> None
     |
     |  Method resolution order:
     |      ServerResult
     |      pydantic.root_model.RootModel[Union[EmptyResult, InitializeResult, CompleteResult, GetPromptResult, ListPromptsResult, ListResourcesResult, ListResourceTemplatesResult, ReadResourceResult, CallToolResult, ListToolsResult]]
     |      pydantic.root_model.RootModel
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {}
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ServerResult'>, '...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'root': FieldInfo(annotation=Union[EmptyResult,...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ServerResult", validat...
     |
     |  __signature__ = <Signature (root: 'RootModelRootType' = PydanticUndefi...
     |
     |  model_config = {}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.root_model.RootModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.root_model.RootModel:
     |
     |  __init_subclass__(**kwargs)
     |      This method is called when a class is subclassed.
     |
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |
     |  model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
     |      Create a new model using the provided root object and update fields set.
     |
     |      Args:
     |          root: The root object of the model.
     |          _fields_set: The set of fields to be updated.
     |
     |      Returns:
     |          The new model.
     |
     |      Raises:
     |          NotImplemented: If the model is not a subclass of `RootModel`.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.root_model.RootModel:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.root_model.RootModel:
     |
     |  __hash__ = None
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  __pydantic_extra__ = None
     |
     |  __pydantic_private__ = None
     |
     |  __pydantic_root_model__ = True
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_fields_set__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'root': FieldInfo(annotation=Union[EmptyResult, Initia...

    class ServerSession(mcp.shared.session.BaseSession)
     |  ServerSession(read_stream: anyio.streams.memory.MemoryObjectReceiveStream[mcp.types.JSONRPCMessage | Exception], write_stream: anyio.streams.memory.MemoryObjectSendStream[mcp.types.JSONRPCMessage], init_options: mcp.server.models.InitializationOptions) -> None
     |
     |  Method resolution order:
     |      ServerSession
     |      mcp.shared.session.BaseSession
     |      typing.Generic
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self, read_stream: anyio.streams.memory.MemoryObjectReceiveStream[mcp.types.JSONRPCMessage | Exception], write_stream: anyio.streams.memory.MemoryObjectSendStream[mcp.types.JSONRPCMessage], init_options: mcp.server.models.InitializationOptions) -> None
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  check_client_capability(self, capability: mcp.types.ClientCapabilities) -> bool
     |      Check if the client supports a specific capability.
     |
     |  async create_message(self, messages: list[mcp.types.SamplingMessage], *, max_tokens: int, system_prompt: str | None = None, include_context: Optional[Literal['none', 'thisServer', 'allServers']] = None, temperature: float | None = None, stop_sequences: list[str] | None = None, metadata: dict[str, typing.Any] | None = None, model_preferences: mcp.types.ModelPreferences | None = None) -> mcp.types.CreateMessageResult
     |      Send a sampling/create_message request.
     |
     |  async list_roots(self) -> mcp.types.ListRootsResult
     |      Send a roots/list request.
     |
     |  async send_log_message(self, level: Literal['debug', 'info', 'notice', 'warning', 'error', 'critical', 'alert', 'emergency'], data: Any, logger: str | None = None) -> None
     |      Send a log message notification.
     |
     |  async send_ping(self) -> mcp.types.EmptyResult
     |      Send a ping request.
     |
     |  async send_progress_notification(self, progress_token: str | int, progress: float, total: float | None = None) -> None
     |      Send a progress notification.
     |
     |  async send_prompt_list_changed(self) -> None
     |      Send a prompt list changed notification.
     |
     |  async send_resource_list_changed(self) -> None
     |      Send a resource list changed notification.
     |
     |  async send_resource_updated(self, uri: pydantic.networks.AnyUrl) -> None
     |      Send a resource updated notification.
     |
     |  async send_tool_list_changed(self) -> None
     |      Send a tool list changed notification.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |
     |  client_params
     |
     |  incoming_messages
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {'_client_params': mcp.types.InitializeRequestParams...
     |
     |  __orig_bases__ = (mcp.shared.session.BaseSession[mcp.types.ServerR...y...
     |
     |  __parameters__ = ()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from mcp.shared.session.BaseSession:
     |
     |  async __aenter__(self) -> Self
     |
     |  async __aexit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: traceback | None) -> bool | None
     |
     |  async send_notification(self, notification: ~SendNotificationT) -> None
     |      Emits a notification, which is a one-way message that does not expect
     |      a response.
     |
     |  async send_request(self, request: ~SendRequestT, result_type: type[~ReceiveResultT]) -> ~ReceiveResultT
     |      Sends a request and wait for a response. Raises an McpError if the
     |      response contains an error.
     |
     |      Do not use this method to emit notifications! Use send_notification()
     |      instead.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from mcp.shared.session.BaseSession:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __class_getitem__(...)
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class SetLevelRequest(Request[SetLevelRequestParams, Literal['logging/setLevel']])
     |  SetLevelRequest(*, method: Literal['logging/setLevel'], params: mcp.types.SetLevelRequestParams, **extra_data: Any) -> None
     |
     |  A request from the client to the server, to enable or adjust logging.
     |
     |  Method resolution order:
     |      SetLevelRequest
     |      Request[SetLevelRequestParams, Literal['logging/setLevel']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['logging/setLevel'], 'para...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.SetLevelRequest'>...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=Literal['logging...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="SetLevelRequest", vali...
     |
     |  __signature__ = <Signature (*, method: Literal['logging/setLevel...etL...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=Literal['logging/setLev...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class StdioServerParameters(pydantic.main.BaseModel)
     |  StdioServerParameters(*, command: str, args: list[str] = <factory>, env: dict[str, str] | None = None, cwd: str | pathlib.Path | None = None, encoding: str = 'utf-8', encoding_error_handler: Literal['strict', 'ignore', 'replace'] = 'strict') -> None
     |
     |  Method resolution order:
     |      StdioServerParameters
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'args': list[str], 'command': <class 'str'>, 'cwd':...
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.client.stdio.StdioServe...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'args': FieldInfo(annotation=list[str], require...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="StdioServerParameters"...
     |
     |  __signature__ = <Signature (*, command: str, args: list[str] = <...tri...
     |
     |  model_config = {}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'args': FieldInfo(annotation=list[str], required=False...

    class SubscribeRequest(Request[SubscribeRequestParams, Literal['resources/subscribe']])
     |  SubscribeRequest(*, method: Literal['resources/subscribe'], params: mcp.types.SubscribeRequestParams, **extra_data: Any) -> None
     |
     |  Sent from the client to request resources/updated notifications from the server
     |  whenever a particular resource changes.
     |
     |  Method resolution order:
     |      SubscribeRequest
     |      Request[SubscribeRequestParams, Literal['resources/subscribe']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['resources/subscribe'], 'p...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.SubscribeRequest'...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=Literal['resourc...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="SubscribeRequest", val...
     |
     |  __signature__ = <Signature (*, method: Literal['resources/subscr...bsc...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=Literal['resources/subs...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

    class Tool(pydantic.main.BaseModel)
     |  Tool(*, name: str, description: str | None = None, inputSchema: dict[str, typing.Any], **extra_data: Any) -> None
     |
     |  Definition for a tool the client can call.
     |
     |  Method resolution order:
     |      Tool
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'description': str | None, 'inputSchema': dict[str,...
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.Tool'>, 'config':...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'description': FieldInfo(annotation=Union[str, ...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="Tool", validator=Model...
     |
     |  __signature__ = <Signature (*, name: str, description: str | Non...ict...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'description': FieldInfo(annotation=Union[str, NoneTyp...

    class ToolsCapability(pydantic.main.BaseModel)
     |  ToolsCapability(*, listChanged: bool | None = None, **extra_data: Any) -> None
     |
     |  Capability for tools operations.
     |
     |  Method resolution order:
     |      ToolsCapability
     |      pydantic.main.BaseModel
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'listChanged': bool | None}
     |
     |  __class_vars__ = set()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.ToolsCapability'>...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'listChanged': FieldInfo(annotation=Union[bool,...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="ToolsCapability", vali...
     |
     |  __signature__ = <Signature (*, listChanged: bool | None = None, **extr...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'listChanged': FieldInfo(annotation=Union[bool, NoneTy...

    class UnsubscribeRequest(Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']])
     |  UnsubscribeRequest(*, method: Literal['resources/unsubscribe'], params: mcp.types.UnsubscribeRequestParams, **extra_data: Any) -> None
     |
     |  Sent from the client to request cancellation of resources/updated notifications from
     |  the server.
     |
     |  Method resolution order:
     |      UnsubscribeRequest
     |      Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {'method': typing.Literal['resources/unsubscribe'], ...
     |
     |  __class_vars__ = set()
     |
     |  __parameters__ = ()
     |
     |  __private_attributes__ = {}
     |
     |  __pydantic_complete__ = True
     |
     |  __pydantic_computed_fields__ = {}
     |
     |  __pydantic_core_schema__ = {'cls': <class 'mcp.types.UnsubscribeReques...
     |
     |  __pydantic_custom_init__ = False
     |
     |  __pydantic_decorators__ = DecoratorInfos(validators={}, field_validato...
     |
     |  __pydantic_fields__ = {'method': FieldInfo(annotation=Literal['resourc...
     |
     |  __pydantic_generic_metadata__ = {'args': (), 'origin': None, 'paramete...
     |
     |  __pydantic_parent_namespace__ = None
     |
     |  __pydantic_post_init__ = None
     |
     |  __pydantic_serializer__ = SchemaSerializer(serializer=Model(
     |      Model...
     |
     |  __pydantic_setattr_handlers__ = {}
     |
     |  __pydantic_validator__ = SchemaValidator(title="UnsubscribeRequest", v...
     |
     |  __signature__ = <Signature (*, method: Literal['resources/unsubs...bsc...
     |
     |  model_config = {'extra': 'allow'}
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |
     |  __orig_bases__ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |
     |  __copy__(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |
     |  __deepcopy__(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |
     |  __delattr__(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |
     |  __getattr__(self, item: 'str') -> 'Any'
     |
     |  __getstate__(self) -> 'dict[Any, Any]'
     |      Helper for pickle.
     |
     |  __init__(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |
     |  __iter__(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |
     |  __pretty__(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]' from pydantic._internal._repr.Representation
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |
     |  __replace__(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |
     |  __repr_args__(self) -> '_repr.ReprArgs'
     |
     |  __repr_name__(self) -> 'str' from pydantic._internal._repr.Representation
     |      Name of the instance's class, used in __repr__.
     |
     |  __repr_recursion__(self, object: 'Any') -> 'str' from pydantic._internal._repr.Representation
     |      Returns the string representation of a recursive object.
     |
     |  __repr_str__(self, join_str: 'str') -> 'str' from pydantic._internal._repr.Representation
     |
     |  __rich_repr__(self) -> 'RichReprResult' from pydantic._internal._repr.Representation
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |
     |  __setattr__(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |
     |  __setstate__(self, state: 'dict[Any, Any]') -> 'None'
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |
     |      If you need `include` or `exclude`, use:
     |
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |
     |  dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |
     |  json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |
     |  model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |
     |      Returns a copy of the model.
     |
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |
     |      Returns:
     |          New model instance.
     |
     |  model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A dictionary representation of the model.
     |
     |  model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |
     |      Returns:
     |          A JSON string representation of the model.
     |
     |  model_post_init(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |
     |  __class_getitem__(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef'
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.
     |
     |  __get_pydantic_core_schema__(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema'
     |
     |  __get_pydantic_json_schema__(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue'
     |      Hook into generating the model's JSON schema.
     |
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |
     |      Returns:
     |          A JSON schema, as a Python object.
     |
     |  __pydantic_init_subclass__(**kwargs: 'Any') -> 'None'
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |
     |  construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |
     |  from_orm(obj: 'Any') -> 'Self'
     |
     |  model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
     |      Creates a new instance of the `Model` class with validated data.
     |
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |
     |  model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
     |      Generates a JSON schema for a model class.
     |
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |
     |      Returns:
     |          The JSON schema for the given model class.
     |
     |  model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
     |      Compute the class name for parametrizations of generic classes.
     |
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |
     |  model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
     |      Try to rebuild the pydantic-core schema for the model.
     |
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |
     |  model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate a pydantic model instance.
     |
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |
     |      Returns:
     |          The validated model instance.
     |
     |  model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |
     |      Validate the given JSON data against the Pydantic model.
     |
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |
     |  model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
     |      Validate the given object with string data against the Pydantic model.
     |
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |
     |      Returns:
     |          The validated Pydantic model.
     |
     |  parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  parse_obj(obj: 'Any') -> 'Self'
     |
     |  parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
     |
     |  schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
     |
     |  schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
     |
     |  update_forward_refs(**localns: 'Any') -> 'None'
     |
     |  validate(value: 'Any') -> 'Self'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |
     |  __fields_set__
     |
     |  model_extra
     |      Get extra fields set during validation.
     |
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |
     |  model_fields_set
     |      Returns the set of fields that have been explicitly set on this model instance.
     |
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __pydantic_extra__
     |
     |  __pydantic_fields_set__
     |
     |  __pydantic_private__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |
     |  __hash__ = None
     |
     |  __pydantic_root_model__ = False
     |
     |  model_computed_fields = {}
     |
     |  model_fields = {'method': FieldInfo(annotation=Literal['resources/unsu...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __init_subclass__(...)
     |      Function to initialize subclasses.

FUNCTIONS
    stdio_client(server: mcp.client.stdio.StdioServerParameters, errlog: <class 'TextIO'> = <_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf-8'>)
        Client transport for stdio: this will connect to a server by spawning a
        process and communicating with it over stdin/stdout.

    stdio_server(stdin: Optional[anyio.AsyncFile[str]] = None, stdout: Optional[anyio.AsyncFile[str]] = None)
        Server transport for stdio: this communicates with an MCP client by reading
        from the current process' stdin and writing to stdout.

DATA
    IncludeContext = typing.Literal['none', 'thisServer', 'allServers']
    LoggingLevel = typing.Literal['debug', 'info', 'notice', 'warning', 'e...
    SamplingRole = typing.Literal['user', 'assistant']
    StopReason = typing.Union[typing.Literal['endTurn', 'stopSequence', 'm...
    __all__ = ['CallToolRequest', 'ClientCapabilities', 'ClientNotificatio...

FILE
    e:\conda\envs\mcp_html\lib\site-packages\mcp\__init__.py


